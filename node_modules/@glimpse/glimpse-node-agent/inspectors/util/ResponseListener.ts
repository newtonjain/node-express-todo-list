'use strict';

import * as _ from 'lodash';
import * as events from 'events';
import * as http from 'http';

interface ServerResponseWithInternals extends http.ServerResponse {
    _header?: string;
    _trailer?: string;
}

export class ResponseListener extends events.EventEmitter {
    private static glimpseResponseListenerProperty = '__glimpseResponseListener';

    public static headersEvent = 'headers';

    constructor(res: http.ServerResponse) {
        super();

        this.patchResponseAddTrailers(res);
        this.patchResponseSetHeader(res);
    }

    public static attachListener(res: http.ServerResponse): ResponseListener {
        let responseListener = res[ResponseListener.glimpseResponseListenerProperty];

        if (!responseListener) {
            responseListener = new ResponseListener(res);

            res[ResponseListener.glimpseResponseListenerProperty] = responseListener;
        }

        return responseListener;
    }

    public static getAllHeaders(res: ServerResponseWithInternals): { [key: string]: string[] } {
        // NOTE: The _header and _trailer properties are implementation details of the Node runtime.
        //       These properties are populated as the response is being written to the wire.
        //       As Node writes certain headers (e.g. Date, Connection) only as the response is written,
        //       we use the properties to ensure we capture *all* headers, not just those written by
        //       the application.

        const headers: { [key: string]: string[] } = {};

        ResponseListener.addFormattedHeaders(headers, res._header);
        ResponseListener.addFormattedHeaders(headers, res._trailer);

        return headers;
    }

    private static addFormattedHeaders(headers: { [key: string]: string[] }, formattedHeaders: string) {
        if (formattedHeaders) {
            const splitHeaders = formattedHeaders.split('\r\n');

            splitHeaders.forEach(splitHeader => {
                const index = splitHeader.indexOf(': ');

                if (index >= 0) {
                    const name = splitHeader.substring(0, index);
                    const value = splitHeader.substring(index + 2);

                    if (name) {
                        const loweredName = name.toLowerCase();

                        if (headers[loweredName]) {
                            headers[loweredName].push(value);
                        }
                        else {
                            headers[loweredName] = [value];
                        }
                    }
                }
            });
        }
    }

    private patchResponseSetHeader(res: http.ServerResponse) {
        const oldSetHeader = res.setHeader;

        const self = this;

        res.setHeader = function newSetHeader(name, value: number | string | string[]) {

            oldSetHeader.apply(this, arguments);

            const newHeaders: { [key: string]: string[] } = {};

            if (Array.isArray(value)) {
                newHeaders[name.toLowerCase()] = value;
            }
            else {
                newHeaders[name.toLowerCase()] = [ value.toString() ];
            }

            self.publishHeaderChanges(newHeaders);
        };
    }

    private patchResponseAddTrailers(res: http.ServerResponse) {
        const oldAddTrailers = res.addTrailers;

        const self = this;

        res.addTrailers = function newAddTrailers(headers: { [key: string]: string }) {

            oldAddTrailers.apply(this, arguments);

            const newHeaders: { [key: string]: string[] } = {};

            _.forOwn(headers, (value, key) => {
                newHeaders[key.toLowerCase()] = [ value ];
            });

            self.publishHeaderChanges(newHeaders);
        };
    }

    private publishHeaderChanges(headers: { [key: string]: string[] }) {
        this.emit(ResponseListener.headersEvent, headers);
    }
}
