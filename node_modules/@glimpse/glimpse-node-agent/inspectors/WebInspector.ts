'use strict';

import { DateTimeValue } from '../configuration/DateTimeValue';
import { IAgent } from '../IAgent';
import { IDateTime } from '../configuration/IDateTime';
import { IServerRequestInspector } from './IServerRequestInspector';
import { RequestHelper, HttpHelper } from '../util/HttpHelper';
import { ResponseListener } from './util/ResponseListener';

import * as http from 'http';

class InspectorResponseContext {
    public constructor(public startTime: DateTimeValue) {
    }
}

interface IServerResponse extends http.ServerResponse {
    __glimpseRequestInspectorContext: InspectorResponseContext;
}

export class WebInspector implements IServerRequestInspector {
    private agent: IAgent;
    private dateTime: IDateTime;

    private getCurrentTimeStamp(): string {
        return DateTimeValue.fromUnixMillisecondTimestamp(Date.now(), process.hrtime()).format();
    }

    public requestStart(req: http.IncomingMessage, res: http.ServerResponse) {

        const context = HttpHelper.getContext(req);
        if (context) {

            const inspectedResponse = <IServerResponse>res;

            inspectedResponse.__glimpseRequestInspectorContext = new InspectorResponseContext(this.dateTime.now);
        }
    }

    /* tslint:disable:no-any */
    public requestEnd(req: http.IncomingMessage, res: http.ServerResponse, content: Array<any>, size: number, requestStartTime: string) {
        /* tslint:enable:no-any */

        // pull context from request instead of context manager, as request/response is more reliable
        const context = HttpHelper.getContext(req);
        if (context) {

            const inspectedResponse = <IServerResponse>res;

            // TODO: https://github.com/Glimpse/Glimpse.Node/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            const encoding = 'utf8';
            for (let i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }

            const combinedContent = content.join('');
            const data = {
                protocol: {
                    identifier: RequestHelper.protocol(req),
                    version: req.httpVersion
                },
                url: RequestHelper.protocol(req) + '://' + RequestHelper.host(req) + req.url,
                method: req.method,
                headers: req.headers,
                startTime: inspectedResponse.__glimpseRequestInspectorContext.startTime.format(),
                isAjax: RequestHelper.header(req, 'X-Glimpse-IsAjax') === 'true',
                clientIp: req.socket.remoteAddress,
                body: {
                    size,
                    encoding,
                    isTruncated: size > HttpHelper.getMaxBodySize(this.agent.providers.configSettings),
                    content: combinedContent
                },
                timing: {
                    requestStart: requestStartTime,
                    requestEnd: this.getCurrentTimeStamp()
                }
            };

            const indices = {
                'request-url': data.url,
                'request-method': data.method,
                'request-datetime': data.startTime
            };

            const types = ['web-request'];

            this.agent.broker.createAndSendMessage(data, types, indices, context);
        }
    }

    /* tslint:disable:no-any */
    public responseEnd(req: http.IncomingMessage, res: http.ServerResponse, content: Array<any>, size: number) {
        /* tslint:enable:no-any */

        // pull context from request instead of context manager, as request/response is more reliable
        const context = HttpHelper.getContext(req);
        if (context) {
            const inspectedResponse = <IServerResponse>res;

            const endTime = this.dateTime.now;

            // TODO: https://github.com/Glimpse/Glimpse.Node/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            const encoding = 'utf8';
            for (let i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }

            const combinedContent = content.join('');
            const data = {
                url: RequestHelper.protocol(req) + '://' + RequestHelper.host(req) + req.url,
                headers: ResponseListener.getAllHeaders(res),
                statusCode: res.statusCode,
                duration: endTime.diff(inspectedResponse.__glimpseRequestInspectorContext.startTime),
                endTime: endTime.format(),
                body: {
                    size,
                    encoding,
                    isTruncated: size > HttpHelper.getMaxBodySize(this.agent.providers.configSettings),
                    content: combinedContent
                },
                timing: {
                    responseEnd: this.getCurrentTimeStamp()
                }
            };

            const indices = {
                'request-duration': data.duration,
                'request-status-code': data.statusCode
            };

            const contentType = data.headers['content-type'];

            if (contentType && contentType.length > 0) {
                indices['request-content-type'] = contentType[0];
            }

            const types = ['web-response'];

            this.agent.broker.createAndSendMessage(data, types, indices, context);
        }
    }

    public init(agent: IAgent) {
        this.agent = agent;
        this.dateTime = agent.providers.dateTime;
    }
}
