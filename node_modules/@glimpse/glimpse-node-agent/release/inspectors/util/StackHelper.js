"use strict";
var os = require('os');
var fs = require('fs');
var path = require('path');
var url = require('url');
var glimpse_node_common_1 = require('@glimpse/glimpse-node-common');
// tslint:disable-next-line:no-var-requires
var sourcemap = require('source-map');
var StackHelper = (function () {
    function StackHelper(errorService) {
        /**
         * cache of generated source files to the SourceMapConsumer instance
         */
        this.mapCache = {};
        this.errorReportingService = errorService;
    }
    /**
     * capture the current stack trace.
     *
     * @stackTopFunction is a function that will mark the top of the stack in the returned trace.
     * All functions include stackTopFunction & above will be omitted.
     *
     * @numFrames - the number of stack frames to capture
     *
     */
    StackHelper.prototype.captureStack = function (stackTopFunction, numFrames) {
        var parsedFrames = [];
        if (numFrames > 0) {
            var obj = {
                stack: undefined
            };
            /* tslint:disable:no-any */
            var saveLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = numFrames;
            Error.captureStackTrace(obj, stackTopFunction);
            Error.stackTraceLimit = saveLimit;
            /* tslint:enable:no-any */
            var frames_1 = obj.stack.split('\n');
            // start parsing at 1 since first entry will say 'error'
            for (var i = 1; i < frames_1.length; i++) {
                if (frames_1[i]) {
                    var frame = this.parseFrameEntry(frames_1[i]);
                    parsedFrames.push(frame);
                }
            }
        }
        return parsedFrames;
    };
    /**
     * given an array of stack frames, apply source map information to create a new array of stack frames.
     * The callback will be invoked with the new stack frames with mapping info avaialable
     */
    StackHelper.prototype.mapFrames = function (frames, callback) {
        var self = this;
        var newFrames = [];
        var callbacksReceived = 0;
        frames.forEach(function (currFrame, idx) {
            self.mapFrame(currFrame, function (newFrame) {
                ++callbacksReceived;
                newFrames[idx] = newFrame;
                if (callbacksReceived === frames.length) {
                    callback(newFrames);
                }
            });
        });
    };
    /**
     * given content, look up the source map UI.  Public for testing purposes.
     */
    StackHelper.prototype.getMappingUriFromContent = function (sourceFile, data) {
        // see source map proposal:  https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
        // TODO: support '//@" in addition to '//#' for the " source mapping Url
        // need to have the string concat below, without it will break remap-istanbul when it tries to use source maps on this file
        var sourceMapMark = '\n//# ' + 'sourceMappingURL=';
        var maploc = undefined;
        var idx = data.lastIndexOf(sourceMapMark);
        if (idx > -1) {
            var line = data.substring(idx + sourceMapMark.length);
            line = line.trim();
            return url.parse(line);
        }
        return maploc;
    };
    /**
     * Parse a string form of a single stack frame and return an IStackFrame instance.  Public for testing purposes.
     */
    StackHelper.prototype.parseFrameEntry = function (source) {
        var openParen, closeParen, colon1, colon2;
        for (var i = 0; i < source.length; i++) {
            switch (source[i]) {
                case '(':
                    if (!openParen) {
                        openParen = i;
                    }
                    break;
                case ')':
                    closeParen = i;
                    break;
                case ':':
                    if (!colon1) {
                        colon1 = i;
                    }
                    else if (!colon2) {
                        colon2 = i;
                    }
                    else {
                        // we want the last two colons, so if both colon1 & colon2 have been set, advance them.
                        colon1 = colon2;
                        colon2 = i;
                    }
                    break;
                default:
                    break;
            }
        }
        var functionName, fileName, line, column;
        if (openParen && closeParen && colon1 && colon2) {
            // case  '    at processImmediate [as _immediateCallback] (timers.js:533:5)'
            functionName = source.substring(7, openParen).trim();
            fileName = source.substring(openParen + 1, colon1).trim();
            line = source.substring(colon1 + 1, colon2);
            column = source.substring(colon2 + 1, closeParen);
        }
        else if (colon1 && colon2) {
            // case '    at d:\\glimpse\\Glimpse.Node.Prototype\\node_modules\\mocha\\lib\\runner.js:352:7'
            functionName = '<anonymous>';
            fileName = source.substring(7, colon1).trim();
            line = source.substring(colon1 + 1, colon2);
            column = source.substring(colon2 + 1);
        }
        else if (openParen && closeParen && source.substring(openParen + 1, closeParen) === 'native') {
            // case '    at Array.forEach (native)'
            functionName = source.substring(7, openParen).trim();
            fileName = 'native';
            line = '0';
            column = '0';
        }
        else {
            if (this.errorReportingService) {
                this.errorReportingService.reportError(glimpse_node_common_1.createStackHelperUnsupportedStackFrameFormat(source));
            }
            functionName = '';
            fileName = '';
            line = '0';
            column = '0';
        }
        return {
            functionName: functionName,
            fileName: fileName,
            lineNumber: parseInt(line, 10),
            columnNumber: parseInt(column, 10),
            source: source
        };
    };
    /**
     * given the existing stack frame, create map a new stack frame where data has been replaced with values from source maps, if available.
     */
    StackHelper.prototype.mapFrame = function (frame, callback) {
        var self = this;
        if (self.mapCache.hasOwnProperty(frame.fileName)) {
            // in the event we didn't load a source map, we'll populate the cache with undefined.
            var mappedFrame = self.createMappedFrame(self.mapCache[frame.fileName], frame);
            callback(mappedFrame);
        }
        else {
            self.getMappingUriFromFile(frame.fileName, function (mappingUri) {
                self.loadSourceMapConsumer(frame.fileName, mappingUri, function (sourceMapConsumer) {
                    // if sourceMapConsumer is undefined, it means there was an error loading it. 
                    // We'll populate cache with undefined so we don't continually try to load it.
                    self.mapCache[frame.fileName] = sourceMapConsumer;
                    var mappedFrame = self.createMappedFrame(sourceMapConsumer, frame);
                    callback(mappedFrame);
                });
            });
        }
    };
    /**
     * given a stack frame & a sourceMapConsumer, return a new stack frame with the
     * generated filename/line/column values replaced with the values from the source map.
     *
     * If sourceMapConsumer is null, then original fram will be returned.
     */
    StackHelper.prototype.createMappedFrame = function (sourceMapConsumer, frame) {
        if (sourceMapConsumer) {
            var position = sourceMapConsumer.originalPositionFor({ line: frame.lineNumber, column: frame.columnNumber });
            frame = {
                functionName: frame.functionName,
                fileName: position.source,
                lineNumber: position.line,
                columnNumber: position.column,
                source: frame.source
            };
            if (os.platform() === 'win32') {
                frame.fileName = frame.fileName.replace(/\//g, '\\');
            }
        }
        return frame;
    };
    /**
     * given a path to a source file, find the source mapping URI, and invoke given callback with UI.
     */
    StackHelper.prototype.getMappingUriFromFile = function (sourceFile, callback) {
        var self = this;
        fs.readFile(sourceFile, 'utf8', function (err, data) {
            var mappingUri = undefined;
            if (data && !err) {
                mappingUri = self.getMappingUriFromContent(sourceFile, data);
            }
            callback(mappingUri);
        });
    };
    /**
     * given a URI to a source map, create a SourceMapConsumer, and invoke the given callback with it.
     */
    StackHelper.prototype.loadSourceMapConsumer = function (generatedFile, uri, callback) {
        if (uri && (!uri.protocol || uri.protocol === 'file:')) {
            var maploc = uri.pathname;
            if (!path.isAbsolute(maploc)) {
                maploc = path.join(path.dirname(generatedFile), maploc);
            }
            if (os.platform() === 'win32') {
                maploc = maploc.replace(/\//g, '\\');
            }
            fs.readFile(maploc, 'utf8', function (err, data) {
                var smc = undefined;
                if (data && !err) {
                    var map = JSON.parse(data);
                    smc = new sourcemap.SourceMapConsumer(map);
                }
                callback(smc);
            });
        }
        else {
            if (uri && this.errorReportingService) {
                // we've got a URI, but it isn't a file or relative path, so we don't support it.  Send telemetry so we know about it. 
                var uriString = url.format(uri);
                this.errorReportingService.reportError(glimpse_node_common_1.createStackHelperUnsupportedSourceMapUriError(uriString));
            }
            callback(undefined);
        }
    };
    return StackHelper;
}());
exports.StackHelper = StackHelper;

//# sourceMappingURL=../../../maps/inspectors/util/StackHelper.js.map
