'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var glimpse_node_common_1 = require('@glimpse/glimpse-node-common');
var ProxyBase_1 = require('./ProxyBase');
var HttpHelper_1 = require('../util/HttpHelper');
var GuidHelper_1 = require('../util/GuidHelper');
var DateTimeValue_1 = require('../configuration/DateTimeValue');
var SESSION_COOKIE = '.Glimpse.Session';
var REQUEST_ID_COOKIE = '.Glimpse.RequestId';
var IS_AJAX_HEADER = 'X-Glimpse-IsAjax';
var HttpProxy = (function (_super) {
    __extends(HttpProxy, _super);
    function HttpProxy() {
        _super.apply(this, arguments);
        this.inspectors = [];
        this.proxiedModules = [];
    }
    Object.defineProperty(HttpProxy.prototype, "moduleName", {
        get: function () { return 'http'; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(HttpProxy.prototype, "forceLoadModule", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    HttpProxy.prototype.raiseRequestStartEvent = function (req, res) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.requestStart(req, res);
        }
    };
    // tslint:disable-next-line:no-any
    HttpProxy.prototype.raiseRequestEndEvent = function (req, res, content, size, requestStartTime) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.requestEnd(req, res, content, size, requestStartTime);
        }
    };
    // tslint:disable-next-line:no-any
    HttpProxy.prototype.raiseResponseEndEvent = function (req, res, content, size) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.responseEnd(req, res, content, size);
        }
    };
    HttpProxy.prototype.getCurrentTimeStamp = function () {
        return DateTimeValue_1.DateTimeValue.fromUnixMillisecondTimestamp(Date.now(), process.hrtime()).format();
    };
    HttpProxy.prototype.setupServerProxy = function (agent, httpModule) {
        var oldCreateServer = httpModule.createServer;
        var self = this;
        var maxBodySize = HttpHelper_1.HttpHelper.getMaxBodySize(agent.providers.configSettings);
        httpModule.createServer = function createServer(options, cb) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            function internalCallback(req, res) {
                var rest = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    rest[_i - 2] = arguments[_i];
                }
                var requestStartTime = self.getCurrentTimeStamp();
                agent.providers.contextManager.runInNewContext(req, function (context) {
                    // store context on req/response
                    HttpHelper_1.HttpHelper.setContext(req, context);
                    HttpHelper_1.HttpHelper.setContext(res, context);
                    self.raiseRequestStartEvent(req, res);
                    // It is possible in some circumstances that `res.end()` is
                    // called before the `data` event on the `req` object is
                    // fired. In this case, we check this flag and send the before
                    // event immediately before sending the end event.
                    var requestEndSent = false;
                    // Note: the User Inspector class was rolled into this one
                    // because the begin/end events weren't fine graind enough
                    // to set these headers at the appropriate time. Once this
                    // module is ported to the new proxy paradigm, this can be
                    // split back into a separate inspector
                    // BEGIN code from UserInspector
                    var requestCookies = HttpHelper_1.RequestHelper.parseCookies(req);
                    var userId = requestCookies ? requestCookies[SESSION_COOKIE] : undefined;
                    if (!userId) {
                        HttpHelper_1.ResponseHelper.setCookie(res, SESSION_COOKIE, GuidHelper_1.GuidHelper.newGuid(false));
                    }
                    // END code from UserInspector
                    res.setHeader('X-Glimpse-ContextId', context.id);
                    // General performance note for this implementation: this has been identified
                    // as a hot path for performance, so there are places where maintainability
                    // and readability are sacrificed for performance. Specifically, there is
                    // repeated code in here that could be abstracted into helper methods, but
                    // would incure the extra stack frame and slow things down
                    // Note on Buffers. We use Buffers to store body requests, and we
                    // create new buffers a few times as well. We use the Buffer consructor
                    // to do this for backwards compatibility reasons, but we should
                    // migrate away some day. There is a security risk with using the
                    // Buffer constructor, which is why it's been deprecated. More info:
                    // https://nodejs.org/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe
                    // Chunks may be read back as either Buffers or strings. For now we store
                    // them as an array of chunks, and let inspectors figure out the best way
                    // to normalize them.
                    var requestBodyChunks = [];
                    var requesBodyLength = 0;
                    var bufferedData = [];
                    var isBufferingData = true;
                    req.on('data', function (chunk) {
                        if (isBufferingData) {
                            bufferedData.push(chunk);
                        }
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'data\')', context.id);
                        var originalChunkLength = chunk.length;
                        if (requesBodyLength < maxBodySize) {
                            if (requesBodyLength + originalChunkLength >= maxBodySize) {
                                chunk = chunk.slice(0, maxBodySize - requesBodyLength);
                            }
                            requestBodyChunks.push(chunk);
                        }
                        requesBodyLength += originalChunkLength;
                    });
                    var isBufferingEnd = false;
                    req.on('end', function () {
                        isBufferingEnd = true;
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'end\')', context.id);
                        if (!requestEndSent) {
                            self.raiseRequestEndEvent(req, res, requestBodyChunks, requesBodyLength, requestStartTime);
                            requestEndSent = true;
                        }
                    });
                    req.on('error', function (err) {
                        self.errorReportingService.reportError(glimpse_node_common_1.createHttpServerError(err));
                    });
                    res.on('error', function (err) {
                        self.errorReportingService.reportError(glimpse_node_common_1.createHttpServerError(err));
                    });
                    // NOTE: We MUST be subscribed to the 'data' and 'end' events PRIOR to patching 'on()'.
                    var oldOn = req.on;
                    req.on = function newOn(event, onCallback) {
                        var _this = this;
                        var onRest = [];
                        for (var _i = 2; _i < arguments.length; _i++) {
                            onRest[_i - 2] = arguments[_i];
                        }
                        if (isBufferingData && event === 'data') {
                            try {
                                bufferedData.forEach(function (chunk) {
                                    onCallback.call(_this, chunk);
                                });
                            }
                            finally {
                                bufferedData = [];
                                isBufferingData = false;
                            }
                        }
                        else if (isBufferingEnd && event === 'end') {
                            onCallback.call(this);
                        }
                        return oldOn.call.apply(oldOn, [this, event, onCallback].concat(onRest));
                    };
                    // Note: it's possible to write data using the `end` method as well,
                    // but that method calls `write` under the hood, and patching both
                    // leads to a doubly patched write method, which duplicates the body
                    var responseBodyChunks = [];
                    var responseBodyLength = 0;
                    var oldWrite = res.write;
                    res.write = function (chunk, encoding) {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(response.write())', context.id);
                        var writeArgs = [];
                        for (var _i = 2; _i < arguments.length; _i++) {
                            writeArgs[_i - 2] = arguments[_i];
                        }
                        // Short circuit if we're not actually writing anything
                        if (typeof chunk === 'function' || typeof chunk === 'undefined') {
                            return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                        }
                        // If we don't have the necessary information to normalize
                        // to a string, the underlying API will throw, so we short
                        // circuit here and call the underlying API
                        if (typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) {
                            return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                        }
                        // Save part or all of the chunk to the set of chunks,
                        // truncating if necessary to keep the set under the
                        // max body size
                        var originalChunkLength = chunk.length;
                        var normalizedChunk = chunk;
                        if (responseBodyLength < maxBodySize) {
                            if (responseBodyLength + originalChunkLength >= maxBodySize) {
                                normalizedChunk = normalizedChunk.slice(0, maxBodySize - responseBodyLength);
                            }
                            responseBodyChunks.push(normalizedChunk);
                        }
                        responseBodyLength += originalChunkLength;
                        return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                    };
                    // We override the setHeader method so we can intercept the
                    // content-type and set the request ID header if this is the
                    // first request for the page. We will know if this request
                    // was the first request for the page if it's a) a request
                    // for HTML and b) it's not an AJAX request because it's not
                    // possible to request HTML content after the initial request
                    // *except* via AJAX.
                    var oldSetHeader = res.setHeader;
                    res.setHeader = function setHeader(name, value) {
                        var setHeaderArgs = [];
                        for (var _i = 2; _i < arguments.length; _i++) {
                            setHeaderArgs[_i - 2] = arguments[_i];
                        }
                        oldSetHeader.call.apply(oldSetHeader, [this, name, value].concat(setHeaderArgs));
                        if (name.toLowerCase() === 'content-type' && value.indexOf('text/html') === 0 && HttpHelper_1.RequestHelper.header(req, IS_AJAX_HEADER) !== 'true') {
                            HttpHelper_1.ResponseHelper.setCookie(res, REQUEST_ID_COOKIE, context.id);
                        }
                    };
                    res.on('finish', function () {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'finish\')', context.id);
                        if (!requestEndSent) {
                            // If we got here, it means that the `res.end()` method
                            // was called before the body was received (if any). User's
                            // will often do this if returning an error status, or
                            // if they know there isn't a body associated with this
                            // request, so we report the body as not existing
                            self.raiseRequestEndEvent(req, res, [], 0, requestStartTime);
                            requestEndSent = true;
                        }
                        self.raiseResponseEndEvent(req, res, responseBodyChunks, responseBodyLength);
                    });
                    if (cb) {
                        cb.apply(void 0, [req, res].concat(rest));
                    }
                });
            }
            ;
            // Note: https.createServer and http.createServer have different signatures:
            // http.createServer([callback])
            // https.createServer(options[, callback])
            // We can't inspect the callback type because the callback is optional,
            // but we can inspect the `options` parameter since it is required for
            // HTTPS calls and HTTP calls don't accept an options object
            if (typeof options !== 'object') {
                cb = options;
                return oldCreateServer.call.apply(oldCreateServer, [this, internalCallback].concat(args));
            }
            else {
                return oldCreateServer.call.apply(oldCreateServer, [this, options, internalCallback].concat(args));
            }
        };
    };
    HttpProxy.prototype.setupInspectorExtensions = function (agent) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.init(agent);
        }
    };
    HttpProxy.prototype.addServerInspector = function (inspector) {
        if (this.proxiedModules.length) {
            throw new Error('Cannot add inspectors after the proxy has been initialized for the first time');
        }
        this.inspectors.push(inspector);
    };
    HttpProxy.prototype.init = function (agent, httpModule, resolvedModulePath, errorReportingService) {
        this.agent = agent;
        this.errorReportingService = errorReportingService;
        // We can only initialize the proxies once, otherwise we will get n
        // copies of all messages because the proxies will nest inside each other
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);
        this.setupServerProxy(agent, httpModule);
        this.setupInspectorExtensions(agent);
        return httpModule;
    };
    ;
    return HttpProxy;
}(ProxyBase_1.ProxyBase));
exports.HttpProxy = HttpProxy;

//# sourceMappingURL=../../maps/inspectors/HttpProxy.js.map
