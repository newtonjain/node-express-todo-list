'use strict';
var DateTimeValue_1 = require('../configuration/DateTimeValue');
var HttpHelper_1 = require('../util/HttpHelper');
var ResponseListener_1 = require('./util/ResponseListener');
var InspectorResponseContext = (function () {
    function InspectorResponseContext(startTime) {
        this.startTime = startTime;
    }
    return InspectorResponseContext;
}());
var WebInspector = (function () {
    function WebInspector() {
    }
    WebInspector.prototype.getCurrentTimeStamp = function () {
        return DateTimeValue_1.DateTimeValue.fromUnixMillisecondTimestamp(Date.now(), process.hrtime()).format();
    };
    WebInspector.prototype.requestStart = function (req, res) {
        var context = HttpHelper_1.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse = res;
            inspectedResponse.__glimpseRequestInspectorContext = new InspectorResponseContext(this.dateTime.now);
        }
    };
    /* tslint:disable:no-any */
    WebInspector.prototype.requestEnd = function (req, res, content, size, requestStartTime) {
        /* tslint:enable:no-any */
        // pull context from request instead of context manager, as request/response is more reliable
        var context = HttpHelper_1.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse = res;
            // TODO: https://github.com/Glimpse/Glimpse.Node/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            var encoding = 'utf8';
            for (var i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }
            var combinedContent = content.join('');
            var data = {
                protocol: {
                    identifier: HttpHelper_1.RequestHelper.protocol(req),
                    version: req.httpVersion
                },
                url: HttpHelper_1.RequestHelper.protocol(req) + '://' + HttpHelper_1.RequestHelper.host(req) + req.url,
                method: req.method,
                headers: req.headers,
                startTime: inspectedResponse.__glimpseRequestInspectorContext.startTime.format(),
                isAjax: HttpHelper_1.RequestHelper.header(req, 'X-Glimpse-IsAjax') === 'true',
                clientIp: req.socket.remoteAddress,
                body: {
                    size: size,
                    encoding: encoding,
                    isTruncated: size > HttpHelper_1.HttpHelper.getMaxBodySize(this.agent.providers.configSettings),
                    content: combinedContent
                },
                timing: {
                    requestStart: requestStartTime,
                    requestEnd: this.getCurrentTimeStamp()
                }
            };
            var indices = {
                'request-url': data.url,
                'request-method': data.method,
                'request-datetime': data.startTime
            };
            var types = ['web-request'];
            this.agent.broker.createAndSendMessage(data, types, indices, context);
        }
    };
    /* tslint:disable:no-any */
    WebInspector.prototype.responseEnd = function (req, res, content, size) {
        /* tslint:enable:no-any */
        // pull context from request instead of context manager, as request/response is more reliable
        var context = HttpHelper_1.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse = res;
            var endTime = this.dateTime.now;
            // TODO: https://github.com/Glimpse/Glimpse.Node/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            var encoding = 'utf8';
            for (var i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }
            var combinedContent = content.join('');
            var data = {
                url: HttpHelper_1.RequestHelper.protocol(req) + '://' + HttpHelper_1.RequestHelper.host(req) + req.url,
                headers: ResponseListener_1.ResponseListener.getAllHeaders(res),
                statusCode: res.statusCode,
                duration: endTime.diff(inspectedResponse.__glimpseRequestInspectorContext.startTime),
                endTime: endTime.format(),
                body: {
                    size: size,
                    encoding: encoding,
                    isTruncated: size > HttpHelper_1.HttpHelper.getMaxBodySize(this.agent.providers.configSettings),
                    content: combinedContent
                },
                timing: {
                    responseEnd: this.getCurrentTimeStamp()
                }
            };
            var indices = {
                'request-duration': data.duration,
                'request-status-code': data.statusCode
            };
            var contentType = data.headers['content-type'];
            if (contentType && contentType.length > 0) {
                indices['request-content-type'] = contentType[0];
            }
            var types = ['web-response'];
            this.agent.broker.createAndSendMessage(data, types, indices, context);
        }
    };
    WebInspector.prototype.init = function (agent) {
        this.agent = agent;
        this.dateTime = agent.providers.dateTime;
    };
    return WebInspector;
}());
exports.WebInspector = WebInspector;

//# sourceMappingURL=../../maps/inspectors/WebInspector.js.map
