'use strict';
var html = require('htmlparser2');
var util = require('util');
var ScriptManager = (function () {
    function ScriptManager(contextManager, resourceProvider) {
        this.contextManager = contextManager;
        this.resourceProvider = resourceProvider;
    }
    ScriptManager.prototype.init = function () {
        var _this = this;
        this.resourceProvider.getResourceDefinitions(function (resources) {
            _this._resources = resources;
        });
    };
    ScriptManager.prototype.injectScript = function (htmlbody, payload) {
        if (typeof htmlbody === 'string' && payload) {
            var parser_1 = new html.Parser({
                onopentag: function onOpenTag(name) {
                    if (name === 'head') {
                        var injectionIndex = parser_1.endIndex + 1;
                        if (htmlbody[parser_1.endIndex - 1] === '/') {
                            // The HEAD element is a "unary" tag so we "extend" it to include the payload...
                            htmlbody = htmlbody.slice(0, parser_1.endIndex - 2) + (">" + payload + "</head>") + htmlbody.slice(injectionIndex);
                        }
                        else {
                            // The HEAD element has start and end tags, so just inject the payload within them... 
                            htmlbody = htmlbody.slice(0, injectionIndex) + payload + htmlbody.slice(injectionIndex);
                        }
                        parser_1.pause();
                    }
                    else if (name === 'body') {
                        var injectionIndex = parser_1.startIndex;
                        // There is no HEAD element, so create one with the injected payload...
                        htmlbody = htmlbody.slice(0, injectionIndex) + ("<head>" + payload + "</head>") + htmlbody.slice(injectionIndex);
                        parser_1.pause();
                    }
                }
            }, {
                decodeEntities: true
            });
            parser_1.write(htmlbody);
            parser_1.end();
        }
        return htmlbody;
    };
    ScriptManager.prototype.getCurrentContextId = function (context) {
        var id = context ? context.id : '00000000-0000-0000-0000-000000000000';
        return id;
    };
    ScriptManager.prototype.hudScript = function (context, resources) {
        var uri = '<script src="%s" id="__glimpse_hud" data-request-id="%s" data-client-template="%s" data-context-template="%s" data-metadata-template="%s"></script>';
        return util.format(uri, resources[ScriptManager.hudScriptTemplate], this.getCurrentContextId(context), resources[ScriptManager.clientScriptTemplate], resources[ScriptManager.contextTemplate], resources[ScriptManager.metadataTemplate]);
    };
    ;
    ScriptManager.prototype.agentScript = function (context, resources) {
        var uri = '<script src="%s" id="__glimpse_browser_agent" data-request-id="%s" data-message-ingress-template="%s"></script>';
        return util.format(uri, resources[ScriptManager.browserAgentScriptTemplate], this.getCurrentContextId(context), resources[ScriptManager.messageIngressTemplate]);
    };
    ;
    ScriptManager.prototype.getScriptTagsForCurrentRequest = function (context) {
        // For the ResourceProviderInProc case, we need a context to get the protocol/host/port info.  
        // This is done synchronously, but we need a current express context to do this.  
        // For the ResourceProviderHTTP, it makes an HTTP call, so this needs to be initialized
        // asynchronously.  However, the call to getScriptTagsForCurrentRequest doesn't not execute 
        // due to the glimpse tracing event pub/sub model.
        if (!this._resources) {
            this.init();
        }
        return this.hudScript(context, this._resources) + this.agentScript(context, this._resources);
    };
    ScriptManager.hudScriptTemplate = 'hudScriptTemplate';
    ScriptManager.clientScriptTemplate = 'clientScriptTemplate';
    ScriptManager.contextTemplate = 'contextTemplate';
    ScriptManager.metadataTemplate = 'metadataTemplate';
    ScriptManager.browserAgentScriptTemplate = 'browserAgentScriptTemplate';
    ScriptManager.messageIngressTemplate = 'messageIngressTemplate';
    return ScriptManager;
}());
exports.ScriptManager = ScriptManager;

//# sourceMappingURL=../../maps/messaging/ScriptManager.js.map
