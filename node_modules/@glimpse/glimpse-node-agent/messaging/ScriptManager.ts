'use strict';

import { IContext, IContextManager } from './IContextManager';
import { IResourceProvider } from '../configuration/IResourceProvider';
import { IScriptManager } from './IScriptManager';

import * as html from 'htmlparser2';
import * as util from 'util';

export class ScriptManager implements IScriptManager {
    private static hudScriptTemplate = 'hudScriptTemplate';
    private static clientScriptTemplate = 'clientScriptTemplate';
    private static contextTemplate = 'contextTemplate';
    private static metadataTemplate = 'metadataTemplate';
    private static browserAgentScriptTemplate = 'browserAgentScriptTemplate';
    private static messageIngressTemplate = 'messageIngressTemplate';

    private _resources: { [key: string]: string };

    public constructor(private contextManager: IContextManager, private resourceProvider: IResourceProvider) {
    }

    public init() {
        this.resourceProvider.getResourceDefinitions((resources) => {
            this._resources = resources;
        });
    }

    public injectScript(htmlbody, payload: string) {
        if (typeof htmlbody === 'string' && payload) {
            const parser = new html.Parser(
                {
                    onopentag: function onOpenTag(name) {
                        if (name === 'head') {
                            const injectionIndex = parser.endIndex + 1;

                            if (htmlbody[parser.endIndex - 1] === '/') {
                                // The HEAD element is a "unary" tag so we "extend" it to include the payload...
                                htmlbody = htmlbody.slice(0, parser.endIndex - 2) + `>${payload}</head>` + htmlbody.slice(injectionIndex);
                            }
                            else {
                                // The HEAD element has start and end tags, so just inject the payload within them... 
                                htmlbody = htmlbody.slice(0, injectionIndex) + payload + htmlbody.slice(injectionIndex);
                            }

                            parser.pause();
                        }
                        else if (name === 'body') {
                            const injectionIndex = parser.startIndex;

                            // There is no HEAD element, so create one with the injected payload...
                            htmlbody = htmlbody.slice(0, injectionIndex) + `<head>${payload}</head>` + htmlbody.slice(injectionIndex);

                            parser.pause();
                        }
                    }
                },
                {
                    decodeEntities: true
                });

            parser.write(htmlbody);
            parser.end();
        }

        return htmlbody;
    }

    private getCurrentContextId(context: IContext) {
        const id = context ? context.id : '00000000-0000-0000-0000-000000000000';
        return id;
    }

    private hudScript(context: IContext, resources) {

        const uri = '<script src="%s" id="__glimpse_hud" data-request-id="%s" data-client-template="%s" data-context-template="%s" data-metadata-template="%s"></script>';

        return util.format(
            uri,
            resources[ScriptManager.hudScriptTemplate],
            this.getCurrentContextId(context),
            resources[ScriptManager.clientScriptTemplate],
            resources[ScriptManager.contextTemplate],
            resources[ScriptManager.metadataTemplate]);
    };

    private agentScript(context: IContext, resources) {
        const uri = '<script src="%s" id="__glimpse_browser_agent" data-request-id="%s" data-message-ingress-template="%s"></script>';

        return util.format(
            uri,
            resources[ScriptManager.browserAgentScriptTemplate],
            this.getCurrentContextId(context),
            resources[ScriptManager.messageIngressTemplate]);
    };

    public getScriptTagsForCurrentRequest(context: IContext) {

        // For the ResourceProviderInProc case, we need a context to get the protocol/host/port info.  
        // This is done synchronously, but we need a current express context to do this.  
        // For the ResourceProviderHTTP, it makes an HTTP call, so this needs to be initialized
        // asynchronously.  However, the call to getScriptTagsForCurrentRequest doesn't not execute 
        // due to the glimpse tracing event pub/sub model.
        if (!this._resources) {
            this.init();
        }

        return this.hudScript(context, this._resources) + this.agentScript(context, this._resources);
    }
}
